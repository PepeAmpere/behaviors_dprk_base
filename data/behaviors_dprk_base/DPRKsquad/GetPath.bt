{
  "name": "main",
  "id": "b5ed7f35-2cd4-41d5-b4d0-60d4b63b8907",
  "type": "supervisedParallel",
  "subtrees": [
    {
      "name": "define properties",
      "id": "6908fac2-95a9-45db-baab-51edb418ce77",
      "type": "sequence",
      "subtrees": [
        {
          "name": "defineInputVariables",
          "id": "ce83a80d-7981-47ef-a6cd-0bc55c52d16f",
          "type": "scriptAction",
          "script": [
            "-- inputs",
            "loc.endPosition = arg.orderData.endPosition",
            "loc.stepAlongPath = arg.orderData.stepAlongPath",
            "loc.leftPointOffset = arg.orderData.leftPointOffset",
            "loc.rightPointOffset = arg.orderData.rightPointOffset",
            "loc.numberPoints = arg.orderData.numberPoints",
            "loc.startPosition = arg.orderData.startPosition",
            "",
            "--helpers",
            "loc.mainPoints = {}"
          ]
        },
        {
          "name": "defineTacPathReq",
          "id": "be7a7bee-0edc-46a0-bc0c-bf3e80d962f6",
          "type": "scriptAction",
          "script": [
            "loc.tacticalPathRequest = FindPath(",
            "    loc.startPosition,",
            "    loc.endPosition,",
            "    {{ avoidance = 10 }}",
            ")"
          ]
        },
        {
          "name": "waitUntilCalcDone",
          "id": "cac13a3f-a5df-4002-8881-0e8b756e81fc",
          "type": "waitUntil",
          "condition": [
            "if loc.tacticalPathRequest:IsReady() then",
            "\tloc.tacticalPath = loc.tacticalPathRequest:Value()",
            "    local function vecLength(v)",
            "        return math.sqrt(v:X()*v:X() + v:Y()*v:Y() + v:Z()*v:Z())",
            "    end",
            "    local function vecSub(a,b)",
            "        return Vec3(a:X()-b:X(), a:Y()-b:Y(), a:Z()-b:Z())",
            "    end",
            "    local function vecAdd(a,b)",
            "        return Vec3(a:X()+b:X(), a:Y()+b:Y(), a:Z()+b:Z())",
            "    end",
            "    local function vecMul(v,s)",
            "        return Vec3(v:X()*s, v:Y()*s, v:Z()*s)",
            "    end",
            "    local function lerp(a,b,t)",
            "        return vecAdd(a, vecMul(vecSub(b,a), t))",
            "    end",
            "",
            "    local segCount = loc.tacticalPath:GetSegmentCount()",
            "    local segLens = {}",
            "    local totalLen = 0",
            "    for i=1, segCount-1 do",
            "        local s = loc.tacticalPath:GetSegmentStart(i)",
            "        local e = loc.tacticalPath:GetSegmentEnd(i)",
            "        local l = s:Distance(e)",
            "        segLens[i] = l",
            "        totalLen = totalLen + l",
            "    end",
            "    if loc.numberPoints == nil or loc.numberPoints < 2 then",
            "        loc.numberPoints = 3",
            "    end",
            "    if loc.stepAlongPath == nil or loc.stepAlongPath < 100 then",
            "        loc.stepAlongPath = 100",
            "    end",
            "",
            "    -- place main points along the path every `stepAlongPath` distance",
            "    loc.mainPoints = {}",
            "    loc.mainPoints[#loc.mainPoints+1] = loc.startPosition",
            "    local targetDist = loc.stepAlongPath",
            "    while targetDist < totalLen do",
            "        local accum = 0",
            "        for i=1, segCount-1 do",
            "            local l = segLens[i]",
            "            local s = loc.tacticalPath:GetSegmentStart(i)",
            "            local e = loc.tacticalPath:GetSegmentEnd(i)",
            "            if accum + l >= targetDist or i == segCount-1 then",
            "                local along = 0",
            "                if l > 0 then along = (targetDist - accum) / l end",
            "                local pt = lerp(s, e, along)",
            "                loc.mainPoints[#loc.mainPoints+1] = pt",
            "                break",
            "            end",
            "            accum = accum + l",
            "        end",
            "        targetDist = targetDist + loc.stepAlongPath",
            "    end",
            "    -- ensure end is included",
            "    loc.mainPoints[#loc.mainPoints+1] = loc.endPosition",
            "",
            "    -- helpers for offsets",
            "    local function vecNormalize(v)",
            "        local len = vecLength(v)",
            "        if len > 0 then",
            "            return vecMul(v, 1/len)",
            "        end",
            "        return v",
            "    end",
            "",
            "    local function vecCross(a, b)",
            "        return Vec3(",
            "            a:Y()*b:Z() - a:Z()*b:Y(),",
            "            a:Z()*b:X() - a:X()*b:Z(),",
            "            a:X()*b:Y() - a:Y()*b:X()",
            "        )",
            "    end",
            "",
            "    -- calculate left/right points for each main point",
            "    loc.leftPoints = {}",
            "    loc.rightPoints = {}",
            "    local up = Vec3(0,0,1)",
            "    for i=1, #loc.mainPoints do",
            "        local current = loc.mainPoints[i]",
            "        local dir",
            "        if i == 1 then",
            "            dir = vecNormalize(vecSub(loc.mainPoints[2], current))",
            "        elseif i == #loc.mainPoints then",
            "            dir = vecNormalize(vecSub(current, loc.mainPoints[i-1]))",
            "        else",
            "            dir = vecNormalize(vecSub(loc.mainPoints[i+1], loc.mainPoints[i-1]))",
            "        end",
            "        local dirH = Vec3(dir:X(), dir:Y(), 0)",
            "        if vecLength(dirH) == 0 then",
            "            dirH = Vec3(1,0,0)",
            "        else",
            "            dirH = vecNormalize(dirH)",
            "        end",
            "        local right = vecNormalize(vecCross(dirH, up))",
            "        loc.rightPoints[i] = vecAdd(current, vecMul(right, loc.rightPointOffset))",
            "        loc.leftPoints[i] = vecAdd(current, vecMul(right, -loc.leftPointOffset))",
            "    end",
            "",
            "    -- precompute markers along each left-right line (loc.numberPoints per line)",
            "    loc.lineMarkers = {}",
            "    local markers = loc.numberPoints or 3",
            "    if markers < 1 then markers = 1 end",
            "    for i=1, math.min(#loc.leftPoints, #loc.rightPoints) do",
            "        loc.lineMarkers[i] = {}",
            "        for j=1, markers do",
            "            local t = 0",
            "            if markers == 1 then",
            "                t = 0.5",
            "            else",
            "                t = (j-1) / (markers-1)",
            "            end",
            "            loc.lineMarkers[i][j] = lerp(loc.leftPoints[i], loc.rightPoints[i], t)",
            "        end",
            "    end",
            "",
            "    loc.output = { nextPosition = loc.mainPoints[2], markers = (loc.lineMarkers and loc.lineMarkers[2]) or {} }",
            "",
            "    loc.outputPathRequest = {}",
            "",
            "    for i = 1, #loc.output.markers do",
            "        loc.outputPathRequest[#loc.outputPathRequest+1] = FindPath(",
            "            loc.output.nextPosition,",
            "            loc.output.markers[i]",
            "        )",
            "    end",
            "    return true",
            "end",
            "return false"
          ]
        },
        {
          "name": "waitUntiAllDone",
          "id": "85631a3b-e99d-4af2-9e8d-a75f3887a92f",
          "type": "waitUntil",
          "condition": [
            "for i=1, #loc.outputPathRequest do",
            "    if loc.outputPathRequest[i]:IsReady() == false then",
            "        return false",
            "    end",
            "end",
            "",
            "loc.outputPath = {}",
            "for i=1, #loc.outputPathRequest do",
            "    loc.outputPath[i] = loc.outputPathRequest[i]:Value()",
            "end",
            "",
            "arg.result.outputPath = loc.tacticalPath",
            "",
            "arg.result.outputPoints = {}",
            "arg.result.outputPartialPaths = {}",
            "for i=1, #loc.outputPathRequest do",
            "    local distToMarker = loc.output.nextPosition:Distance(loc.output.markers[i])",
            "    arg.result.outputPoints[i] = loc.outputPath[i]:PositionAlongPath(distToMarker)",
            "    arg.result.outputPartialPaths[i] = loc.outputPath[i]",
            "end",
            "",
            "return true"
          ]
        }
      ]
    }
  ],
  "meta": {
    "nodesInfo": [
      {
        "id": "b5ed7f35-2cd4-41d5-b4d0-60d4b63b8907",
        "position": "1215,1174.6",
        "width": 155.00000000000023
      },
      {
        "id": "114240bc-6279-4c4d-bf21-d636ad0da504",
        "position": "875,1312.1"
      },
      {
        "id": "d84d59f1-a7e2-420e-b495-f72eb73d8cd4",
        "position": "1087.5,949.6"
      },
      {
        "id": "6908fac2-95a9-45db-baab-51edb418ce77",
        "position": "1220.5,1424.6"
      },
      {
        "id": "ce83a80d-7981-47ef-a6cd-0bc55c52d16f",
        "position": "895.5,1549.6"
      },
      {
        "id": "be7a7bee-0edc-46a0-bc0c-bf3e80d962f6",
        "position": "1058,1549.6"
      },
      {
        "id": "cac13a3f-a5df-4002-8881-0e8b756e81fc",
        "position": "1220.5,1549.6"
      },
      {
        "id": "85631a3b-e99d-4af2-9e8d-a75f3887a92f",
        "position": "1383,1549.6"
      }
    ],
    "editorObjects": [
      {
        "id": "114240bc-6279-4c4d-bf21-d636ad0da504",
        "type": "comment",
        "header": "Main logic",
        "body": "- maping input variables on locals\r\n- calling build-in FindPath\r\n- calculating all main points on road in given steps\r\n- calculating all positions on those poinst\r\n- finding accesible next poits throught FindPath\r\n  with maximum distance\r\n- return next tupple of positions, main path\r\n   and partical paths in outputs variables",
        "bodyAlignment": "Left",
        "width": 672.33333333333326,
        "height": 328.0,
        "headerBackground": "#FF00FF00",
        "headerForeground": "#FF000000",
        "boxBackground": "#FF90EE90",
        "boxForeground": "#FF000000"
      },
      {
        "id": "d84d59f1-a7e2-420e-b495-f72eb73d8cd4",
        "type": "comment",
        "header": "Input data",
        "body": "- orderData.startPosition - initial position\r\n- orderData.endPosition - destination\r\n- orderData.stepAlongPath - length between steps\r\n- orderData.numberPoints - number of positions in each step\r\n- orderData.leftPointOffset - destination of max left position\r\n- orderData.rightPointOffset - destination of max right position\r\n\r\n--- debug parameters ---\r\n- orderData.debugPath - drawing main path from start to end\r\n- orderData.debugPartialPath - drawing path of each team to his position\r\n- orderData.debugPosition - drawing positions of each team",
        "bodyAlignment": "Left",
        "width": 404.0,
        "height": 311.0,
        "headerBackground": "#FF00FF00",
        "headerForeground": "#FF000000",
        "boxBackground": "#FF90EE90",
        "boxForeground": "#FF000000"
      }
    ],
    "canvasSize": "3840,2625.5",
    "gridPadding": "0,12.0999999999999"
  },
  "parameters": [
    {
      "name": "orderData",
      "isOptional": false,
      "defaultValue": "",
      "evaluation": "passByReference"
    },
    {
      "name": "result",
      "isOptional": false,
      "defaultValue": "",
      "evaluation": "passByReference"
    }
  ],
  "locals": {
    "tacticalPath": "return nil",
    "tacticalPathRequest": "return nil",
    "startPosition": "return nil",
    "endPosition": "return nil",
    "stepAlongPath": "return nil",
    "leftPointOffset": "return nil",
    "rightPointOffset": "return nil",
    "numberPoints": "return nil",
    "leftPoints": "return nil",
    "rightPoints": "return nil",
    "lineMarkers": "return nil",
    "mainPoints": "return nil",
    "output": "return nil",
    "outputPathRequest": "return nil",
    "outputPath": "return nil"
  }
}